<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adaptive Learning Engine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        'primary-dark': '#4A49C7'
                    }
                }
            }
        }

        // Configure MathJax
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <style>
        .question-option {
            transition: all 0.3s ease;
        }
        .question-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .dark .question-option:hover {
            box-shadow: 0 4px 12px rgba(255,255,255,0.1);
        }
        .mastery-bar {
            transition: width 0.5s ease-in-out;
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Visual Content Styles */
        .visual-content {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .dark .visual-content {
            box-shadow: 0 2px 8px rgba(255,255,255,0.1);
        }
        
        .chemical-structure {
            background: white;
            padding: 1rem;
            border-radius: 8px;
        }
        .dark .chemical-structure {
            background: #374151;
        }
        
        .circuit-diagram {
            background: #f8fafc;
            padding: 1rem;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
        }
        .dark .circuit-diagram {
            background: #1f2937;
            border-color: #374151;
        }
        
        .data-table {
            overflow-x: auto;
        }
        
        .animation-controls {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .latex-container {
            text-align: center;
            padding: 1rem;
            background: #f8fafc;
            border-radius: 8px;
            margin: 1rem 0;
        }
        .dark .latex-container {
            background: #1f2937;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen transition-colors duration-300">
    <div id="app" class="container mx-auto px-4 py-6 max-w-4xl">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-3xl font-bold text-primary mb-2">Adaptive Learning Engine</h1>
            <p class="text-gray-600 dark:text-gray-400">Hyper-personalized biology learning powered by AI</p>
        </header>

        <!-- Dashboard View -->
        <div id="dashboard-view" class="space-y-6">
            <!-- User Stats -->
            <div class="bg-gradient-to-r from-primary to-primary-dark text-white rounded-lg p-6">
                <h2 class="text-xl font-semibold mb-4">Your Learning Profile</h2>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div class="text-center">
                        <div class="text-2xl font-bold" id="total-mastery">0%</div>
                        <div class="text-sm opacity-90">Overall Mastery</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold" id="questions-answered">0</div>
                        <div class="text-sm opacity-90">Questions Answered</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold" id="predicted-time">--</div>
                        <div class="text-sm opacity-90">Est. Time to Mastery</div>
                    </div>
                </div>
            </div>

            <!-- Skill Breakdown -->
            <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-6">
                <h3 class="text-lg font-semibold mb-4">Skill Mastery Breakdown</h3>
                <div id="skills-breakdown" class="space-y-3">
                    <!-- Dynamically populated -->
                </div>
            </div>

            <!-- Learning Insights -->
            <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-6">
                <h3 class="text-lg font-semibold mb-4">Learning Insights</h3>
                <div id="learning-insights" class="text-gray-700 dark:text-gray-300">
                    <p>Complete a few questions to see personalized insights!</p>
                </div>
            </div>

            <!-- Start Learning Button -->
            <div class="text-center">
                <button id="start-learning" class="bg-primary hover:bg-primary-dark text-white px-8 py-3 rounded-lg text-lg font-semibold transition-colors duration-200">
                    Start Adaptive Learning
                </button>
            </div>
        </div>

        <!-- Question View -->
        <div id="question-view" class="hidden">
            <!-- Progress Bar -->
            <div class="mb-6">
                <div class="flex justify-between text-sm text-gray-600 dark:text-gray-400 mb-2">
                    <span>Question <span id="current-question">1</span></span>
                    <span>Difficulty: <span id="question-difficulty" class="font-semibold"></span>/5</span>
                </div>
                <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                    <div id="progress-bar" class="bg-primary h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
            </div>

            <!-- Question Card -->
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 mb-6">
                <div class="mb-4">
                    <div class="text-sm text-gray-500 dark:text-gray-400 mb-2" id="question-source"></div>
                    <h3 class="text-xl font-semibold mb-4" id="question-text"></h3>
                    
                    <!-- Enhanced Visual Content Container -->
                    <div id="question-visual" class="mb-6 hidden">
                        <div id="visual-content-container" class="visual-content">
                            <!-- Dynamically populated based on content type -->
                        </div>
                        <p id="visual-caption" class="text-sm text-gray-600 dark:text-gray-400 mt-2 text-center hidden"></p>
                    </div>
                </div>

                <!-- Options -->
                <div id="question-options" class="space-y-3">
                    <!-- Dynamically populated -->
                </div>

                <!-- Hints -->
                <div id="hints-section" class="mt-6 hidden">
                    <button id="hint-button" class="text-primary hover:text-primary-dark text-sm font-medium">
                        üí° Need a hint?
                    </button>
                    <div id="hint-text" class="mt-2 p-3 bg-blue-50 dark:bg-blue-900/30 border-l-4 border-blue-400 text-blue-800 dark:text-blue-200 hidden"></div>
                </div>

                <!-- Confidence Slider -->
                <div class="mt-6">
                    <label class="block text-sm font-medium mb-2">How confident are you? <span id="confidence-value">50%</span></label>
                    <input type="range" id="confidence-slider" min="0" max="100" value="50" 
                           class="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex justify-between">
                <button id="back-to-dashboard" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors">
                    ‚Üê Back to Dashboard
                </button>
                <button id="submit-answer" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    Submit Answer
                </button>
            </div>
        </div>

        <!-- Feedback View -->
        <div id="feedback-view" class="hidden">
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6">
                <div id="feedback-header" class="text-center mb-6">
                    <div id="feedback-icon" class="text-6xl mb-2"></div>
                    <h3 id="feedback-title" class="text-2xl font-bold mb-2"></h3>
                    <p id="feedback-subtitle" class="text-gray-600 dark:text-gray-400"></p>
                </div>

                <div id="feedback-explanation" class="mb-6 p-4 bg-gray-50 dark:bg-gray-700 rounded-lg">
                    <!-- Dynamically populated -->
                </div>

                <div id="remediation-section" class="mb-6 hidden">
                    <h4 class="font-semibold text-lg mb-3">Personalized Remediation</h4>
                    <div id="remediation-content" class="p-4 bg-blue-50 dark:bg-blue-900/30 border-l-4 border-blue-400 rounded">
                        <!-- Dynamically populated -->
                    </div>
                </div>

                <div id="skill-update" class="mb-6 hidden">
                    <h4 class="font-semibold text-lg mb-3">Skill Mastery Update</h4>
                    <div id="skill-changes">
                        <!-- Dynamically populated -->
                    </div>
                </div>

                <div class="flex justify-center space-x-4">
                    <button id="next-question" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">
                        Next Question
                    </button>
                    <button id="view-analytics" class="border border-primary text-primary hover:bg-primary hover:text-white px-6 py-2 rounded-lg transition-colors">
                        View Analytics
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Dark mode setup
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Enhanced Question Bank with Visual Content
        const questionBank = [
            {
                id: "bio-cell-001",
                question: "Which of the following is characteristic of animal cells?",
                visual_content: {
                    type: "diagram",
                    format: "svg",
                    file: "cell_comparison.svg",
                    alt_text: "Comparison of plant and animal cell structures",
                    caption: "Plant cell (left) vs Animal cell (right)"
                },
                options: [
                    "Presence of chloroplasts",
                    "Possession of a cellulose cell wall", 
                    "Absence of large vacuoles",
                    "Presence of large vacuoles",
                    "Presence of chromosomes"
                ],
                answer: 2,
                explanation: "Animal cells have few, scattered small vacuoles. Presence of chromosomes is common to ALL cells.",
                difficulty: { value: 2, scale: "1-5" },
                source: "1978 Q13",
                skills: ["CEL01"],
                topics: ["TOPIC01", "TOPIC05"],
                prerequisite_skills: ["CEL_BASIC01"],
                common_misconceptions: [
                    { option: 0, skill_gap: "CEL02", remediation_id: "REM01" },
                    { option: 1, skill_gap: "CEL03", remediation_id: "REM02" }
                ],
                bloom_taxonomy_level: 1,
                hints: [
                    { text: "Think about what organelles are unique to plant vs animal cells.", reveal_after_attempt: 1 },
                    { text: "Animal cells don't need large water storage like plants do.", reveal_after_attempt: 2 }
                ],
                calculation_based: false,
                estimated_time: 45,
                discrimination_index: 0.42,
                guess_probability: 0.20
            },
            {
                id: "chem-bond-001",
                question: "What type of chemical bond is represented in the equation below?",
                visual_content: [
                    {
                        type: "chemical_structure",
                        format: "svg",
                        content: `<svg viewBox="0 0 300 100" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="50" cy="50" r="20" fill="#FFD700" stroke="#000" stroke-width="2"/>
                            <text x="50" y="55" text-anchor="middle" font-size="14" font-weight="bold">Na‚Å∫</text>
                            <circle cx="150" cy="50" r="25" fill="#90EE90" stroke="#000" stroke-width="2"/>
                            <text x="150" y="55" text-anchor="middle" font-size="14" font-weight="bold">Cl‚Åª</text>
                            <line x1="75" y1="50" x2="125" y2="50" stroke="#FF6B6B" stroke-width="3"/>
                            <text x="100" y="40" text-anchor="middle" font-size="12">ionic bond</text>
                            <text x="150" y="85" text-anchor="middle" font-size="12">NaCl</text>
                        </svg>`,
                        alt_text: "Sodium chloride ionic bond formation diagram",
                        caption: "Formation of sodium chloride (NaCl)"
                    },
                    {
                        type: "latex_equation",
                        content: "\\ce{Na^+ + Cl^- -> NaCl}",
                        display_mode: "block",
                        caption: "Ionic bond formation equation"
                    }
                ],
                options: [
                    "Ionic bond",
                    "Covalent bond",
                    "Metallic bond",
                    "Hydrogen bond"
                ],
                answer: 0,
                explanation: "Ionic bonds form between metals and non-metals through electron transfer, creating charged ions that attract each other.",
                difficulty: { value: 2, scale: "1-5" },
                source: "Chemistry Fundamentals",
                skills: ["CHEM01"],
                topics: ["BONDING"],
                prerequisite_skills: ["CHEM_BASIC01"],
                common_misconceptions: [
                    { option: 1, skill_gap: "CHEM02", remediation_id: "REM07" }
                ],
                bloom_taxonomy_level: 2,
                hints: [
                    { text: "Look at the charges on the atoms - one is positive, one is negative.", reveal_after_attempt: 1 },
                    { text: "This bond forms between a metal and a non-metal.", reveal_after_attempt: 2 }
                ],
                calculation_based: false,
                estimated_time: 40,
                discrimination_index: 0.58,
                guess_probability: 0.25
            },
            {
                id: "physics-circuit-001",
                question: "What is the total resistance in this series circuit?",
                visual_content: {
                    type: "circuit_diagram",
                    format: "svg",
                    content: `<svg viewBox="0 0 400 200" xmlns="http://www.w3.org/2000/svg" class="w-full h-48">
                        <!-- Battery -->
                        <rect x="50" y="80" width="30" height="40" fill="none" stroke="#000" stroke-width="2"/>
                        <line x1="60" y1="70" x2="60" y2="80" stroke="#000" stroke-width="2"/>
                        <line x1="70" y1="70" x2="70" y2="80" stroke="#000" stroke-width="2"/>
                        <text x="65" y="65" text-anchor="middle" font-size="12">9V</text>
                        
                        <!-- Resistors -->
                        <rect x="150" y="90" width="40" height="20" fill="none" stroke="#000" stroke-width="2"/>
                        <text x="170" y="85" text-anchor="middle" font-size="10">100Œ©</text>
                        
                        <rect x="250" y="90" width="40" height="20" fill="none" stroke="#000" stroke-width="2"/>
                        <text x="270" y="85" text-anchor="middle" font-size="10">200Œ©</text>
                        
                        <!-- Wires -->
                        <line x1="80" y1="100" x2="150" y2="100" stroke="#000" stroke-width="2"/>
                        <line x1="190" y1="100" x2="250" y2="100" stroke="#000" stroke-width="2"/>
                        <line x1="290" y1="100" x2="350" y2="100" stroke="#000" stroke-width="2"/>
                        <line x1="350" y1="100" x2="350" y2="140" stroke="#000" stroke-width="2"/>
                        <line x1="350" y1="140" x2="50" y2="140" stroke="#000" stroke-width="2"/>
                        <line x1="50" y1="140" x2="50" y2="120" stroke="#000" stroke-width="2"/>
                        
                        <!-- Labels -->
                        <text x="200" y="170" text-anchor="middle" font-size="14" font-weight="bold">Series Circuit</text>
                    </svg>`,
                    alt_text: "Series circuit with 9V battery and two resistors (100Œ© and 200Œ©)",
                    caption: "Series circuit with two resistors"
                },
                options: [
                    "100Œ©",
                    "200Œ©", 
                    "300Œ©",
                    "150Œ©"
                ],
                answer: 2,
                explanation: "In a series circuit, total resistance equals the sum of individual resistances: R_total = R‚ÇÅ + R‚ÇÇ = 100Œ© + 200Œ© = 300Œ©",
                difficulty: { value: 2, scale: "1-5" },
                source: "Physics - Electricity",
                skills: ["PHYS01"],
                topics: ["CIRCUITS"],
                prerequisite_skills: ["PHYS_BASIC01"],
                common_misconceptions: [
                    { option: 3, skill_gap: "PHYS02", remediation_id: "REM08" }
                ],
                bloom_taxonomy_level: 3,
                hints: [
                    { text: "In series circuits, resistances add together.", reveal_after_attempt: 1 },
                    { text: "R_total = R‚ÇÅ + R‚ÇÇ + R‚ÇÉ + ...", reveal_after_attempt: 2 }
                ],
                calculation_based: true,
                estimated_time: 50,
                discrimination_index: 0.72,
                guess_probability: 0.25
            },
            {
                id: "bio-data-001",
                question: "Based on the population data below, what trend is most evident?",
                visual_content: {
                    type: "table",
                    data: {
                        headers: ["Year", "Rabbit Population", "Fox Population"],
                        rows: [
                            ["2020", "1000", "50"],
                            ["2021", "800", "80"],
                            ["2022", "600", "90"],
                            ["2023", "500", "85"],
                            ["2024", "400", "70"]
                        ],
                        caption: "Predator-Prey Population Data"
                    }
                },
                options: [
                    "Both populations are increasing",
                    "Rabbit population decreases as fox population initially increases",
                    "Fox population is independent of rabbit population",
                    "Both populations remain constant"
                ],
                answer: 1,
                explanation: "This shows a classic predator-prey relationship where increased predator population (foxes) leads to decreased prey population (rabbits).",
                difficulty: { value: 3, scale: "1-5" },
                source: "Ecology Data Analysis",
                skills: ["BIO02"],
                topics: ["ECOLOGY"],
                prerequisite_skills: ["BIO_BASIC01"],
                common_misconceptions: [
                    { option: 2, skill_gap: "BIO03", remediation_id: "REM09" }
                ],
                bloom_taxonomy_level: 4,
                hints: [
                    { text: "Look at how the two populations change relative to each other over time.", reveal_after_attempt: 1 },
                    { text: "Consider what foxes eat and how this affects their populations.", reveal_after_attempt: 2 }
                ],
                calculation_based: false,
                estimated_time: 60,
                discrimination_index: 0.68,
                guess_probability: 0.25
            },
            {
                id: "math-calc-001",
                question: "What is the derivative of the function shown below?",
                visual_content: {
                    type: "latex_equation",
                    content: "f(x) = x^3 + 2x^2 - 5x + 3",
                    display_mode: "block",
                    caption: "Function to differentiate"
                },
                options: [
                    "$f'(x) = 3x^2 + 4x - 5$",
                    "$f'(x) = x^3 + 2x^2 - 5x$",
                    "$f'(x) = 3x^2 + 2x - 5$",
                    "$f'(x) = 3x^2 + 4x + 3$"
                ],
                answer: 0,
                explanation: "Using the power rule: $\\frac{d}{dx}[x^n] = nx^{n-1}$. So $f'(x) = 3x^2 + 4x - 5$.",
                difficulty: { value: 3, scale: "1-5" },
                source: "Calculus Fundamentals",
                skills: ["MATH01"],
                topics: ["CALCULUS"],
                prerequisite_skills: ["MATH_BASIC01"],
                common_misconceptions: [
                    { option: 2, skill_gap: "MATH02", remediation_id: "REM10" }
                ],
                bloom_taxonomy_level: 3,
                hints: [
                    { text: "Apply the power rule to each term separately.", reveal_after_attempt: 1 },
                    { text: "Remember: the derivative of a constant is zero.", reveal_after_attempt: 2 }
                ],
                calculation_based: true,
                estimated_time: 45,
                discrimination_index: 0.75,
                guess_probability: 0.25
            }
        ];

        // Enhanced skill definitions
        const skillDefinitions = {
            "CEL01": "Animal Cell Characteristics",
            "CEL02": "Chloroplast Function", 
            "CEL03": "Cell Wall Properties",
            "CEL04": "Mitochondria Function",
            "CEL05": "Nucleus Function",
            "CEL06": "Ribosome Function",
            "CEL_BASIC01": "Basic Cell Knowledge",
            "CHEM01": "Chemical Bonding",
            "CHEM02": "Covalent vs Ionic Bonds",
            "CHEM_BASIC01": "Basic Chemistry",
            "PHYS01": "Circuit Analysis",
            "PHYS02": "Series vs Parallel",
            "PHYS_BASIC01": "Basic Physics",
            "BIO02": "Population Dynamics",
            "BIO03": "Ecological Relationships", 
            "BIO_BASIC01": "Basic Biology",
            "MATH01": "Derivative Calculation",
            "MATH02": "Power Rule Application",
            "MATH_BASIC01": "Basic Mathematics"
        };

        // Enhanced remediation content
        const remediationContent = {
            "REM01": "Chloroplasts are unique to plant cells and contain chlorophyll for photosynthesis. Animal cells don't have chloroplasts because they can't make their own food.",
            "REM02": "Cell walls made of cellulose provide structural support to plant cells. Animal cells have flexible cell membranes instead of rigid walls.",
            "REM03": "The nucleus is the control center containing DNA, but it doesn't produce energy. Think about which organelle has 'energy' in its primary function.",
            "REM04": "Ribosomes make proteins, not energy. The 'powerhouse' nickname specifically refers to ATP (energy) production.",
            "REM05": "Cellular respiration occurs in mitochondria, not chloroplasts. Chloroplasts do the opposite - they capture light energy.",
            "REM06": "Protein synthesis happens at ribosomes, which can be free-floating or attached to the ER.",
            "REM07": "Covalent bonds involve sharing electrons between non-metals, while ionic bonds involve transfer of electrons between metals and non-metals.",
            "REM08": "In parallel circuits, resistances combine differently: 1/R_total = 1/R‚ÇÅ + 1/R‚ÇÇ. In series, they simply add.",
            "REM09": "Predator and prey populations are interconnected - when predators increase, prey typically decreases due to increased hunting pressure.",
            "REM10": "When differentiating $2x^2$, apply the power rule: bring down the exponent (2) and reduce the power by 1, giving $2 \\cdot 2x^1 = 4x$."
        };

        // Type-safe DOM element helper
        function getElement(id, required = true) {
            const element = document.getElementById(id);
            if (required && !element) {
                console.error(`Required element with id '${id}' not found`);
                return null;
            }
            return element;
        }

        // Type-safe event handler helper
        function addEventListenerSafe(element, event, handler) {
            if (element && typeof handler === 'function') {
                element.addEventListener(event, handler);
                return true;
            }
            console.warn('Failed to add event listener: invalid element or handler');
            return false;
        }

        // Visual Content Renderer with enhanced type safety
        class VisualContentRenderer {
            static render(visualContent, container) {
                if (!container || !visualContent) {
                    console.warn('VisualContentRenderer: Missing container or content');
                    return;
                }
                
                container.innerHTML = '';
                
                if (Array.isArray(visualContent)) {
                    visualContent.forEach(content => {
                        if (content && typeof content === 'object') {
                            this.renderSingle(content, container);
                        }
                    });
                } else if (typeof visualContent === 'object') {
                    this.renderSingle(visualContent, container);
                }
            }

            static renderSingle(content, container) {
                if (!content || !container || typeof content !== 'object') {
                    console.warn('VisualContentRenderer: Invalid content or container');
                    return;
                }
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'mb-4';

                try {
                    switch (content.type) {
                        case 'latex_equation':
                            this.renderLatex(content, contentDiv);
                            break;
                        case 'chemical_structure':
                            this.renderChemicalStructure(content, contentDiv);
                            break;
                        case 'circuit_diagram':
                            this.renderCircuit(content, contentDiv);
                            break;
                        case 'table':
                            this.renderTable(content, contentDiv);
                            break;
                        case 'graph':
                            this.renderGraph(content, contentDiv);
                            break;
                        case 'diagram':
                            this.renderDiagram(content, contentDiv);
                            break;
                        case 'animation':
                            this.renderAnimation(content, contentDiv);
                            break;
                        default:
                            this.renderDefault(content, contentDiv);
                    }

                    if (content.caption && typeof content.caption === 'string') {
                        const caption = document.createElement('p');
                        caption.className = 'text-sm text-gray-600 dark:text-gray-400 mt-2 text-center';
                        caption.textContent = content.caption;
                        contentDiv.appendChild(caption);
                    }

                    container.appendChild(contentDiv);
                } catch (error) {
                    console.error('Error rendering visual content:', error);
                    this.renderError(contentDiv);
                    container.appendChild(contentDiv);
                }
            }

            static renderLatex(content, container) {
                if (!content.content || typeof content.content !== 'string') {
                    this.renderError(container);
                    return;
                }

                const latexDiv = document.createElement('div');
                latexDiv.className = `latex-container ${content.display_mode === 'block' ? 'text-center' : 'inline-block'}`;
                
                if (content.display_mode === 'block') {
                    latexDiv.innerHTML = `$$${content.content}$$`;
                } else {
                    latexDiv.innerHTML = `$${content.content}$`;
                }
                
                container.appendChild(latexDiv);
                
                // Re-render MathJax for this element
                if (window.MathJax && typeof window.MathJax.typesetPromise === 'function') {
                    window.MathJax.typesetPromise([latexDiv]).catch(err => {
                        console.error('MathJax error:', err);
                    });
                }
            }

            static renderChemicalStructure(content, container) {
                const structureDiv = document.createElement('div');
                structureDiv.className = 'chemical-structure text-center';
                
                if (content.content && typeof content.content === 'string') {
                    structureDiv.innerHTML = content.content;
                } else if (content.file && typeof content.file === 'string') {
                    const img = document.createElement('img');
                    img.src = `src/images/chemistry/compounds/${content.file}`;
                    img.alt = content.alt_text || 'Chemical structure';
                    img.className = 'max-w-full h-auto mx-auto';
                    img.onerror = () => this.renderImageError(img);
                    structureDiv.appendChild(img);
                } else {
                    this.renderError(structureDiv);
                }
                
                container.appendChild(structureDiv);
            }

            static renderCircuit(content, container) {
                const circuitDiv = document.createElement('div');
                circuitDiv.className = 'circuit-diagram text-center';
                
                if (content.content && typeof content.content === 'string') {
                    circuitDiv.innerHTML = content.content;
                } else if (content.file && typeof content.file === 'string') {
                    const img = document.createElement('img');
                    img.src = `src/images/physics/circuits/${content.file}`;
                    img.alt = content.alt_text || 'Circuit diagram';
                    img.className = 'max-w-full h-auto mx-auto';
                    img.onerror = () => this.renderImageError(img);
                    circuitDiv.appendChild(img);
                } else {
                    this.renderError(circuitDiv);
                }
                
                container.appendChild(circuitDiv);
            }

            static renderTable(content, container) {
                if (!content.data || !Array.isArray(content.data.headers) || !Array.isArray(content.data.rows)) {
                    this.renderError(container);
                    return;
                }

                const tableDiv = document.createElement('div');
                tableDiv.className = 'data-table';
                
                const table = document.createElement('table');
                table.className = 'w-full border-collapse border border-gray-300 dark:border-gray-600';
                
                // Headers
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                headerRow.className = 'bg-gray-50 dark:bg-gray-700';
                
                content.data.headers.forEach(header => {
                    const th = document.createElement('th');
                    th.className = 'border border-gray-300 dark:border-gray-600 px-4 py-2 text-left font-semibold';
                    th.textContent = String(header);
                    headerRow.appendChild(th);
                });
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Body
                const tbody = document.createElement('tbody');
                content.data.rows.forEach((row, index) => {
                    if (!Array.isArray(row)) return;
                    
                    const tr = document.createElement('tr');
                    tr.className = index % 2 === 0 ? 'bg-white dark:bg-gray-800' : 'bg-gray-50 dark:bg-gray-700';
                    
                    row.forEach(cell => {
                        const td = document.createElement('td');
                        td.className = 'border border-gray-300 dark:border-gray-600 px-4 py-2';
                        td.textContent = String(cell);
                        tr.appendChild(td);
                    });
                    
                    tbody.appendChild(tr);
                });
                
                table.appendChild(tbody);
                tableDiv.appendChild(table);
                container.appendChild(tableDiv);
            }

            static renderGraph(content, container) {
                if (!content.data || !window.Chart) {
                    this.renderError(container);
                    return;
                }

                const graphDiv = document.createElement('div');
                graphDiv.className = 'w-full h-64';
                const canvas = document.createElement('canvas');
                graphDiv.appendChild(canvas);
                
                try {
                    const ctx = canvas.getContext('2d');
                    new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: content.data.x_values || [],
                            datasets: [{
                                label: content.data.title || 'Data',
                                data: content.data.y_values || [],
                                borderColor: '#5D5CDE',
                                backgroundColor: 'rgba(93, 92, 222, 0.1)',
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: { title: { display: true, text: content.data.x_label || 'X' } },
                                y: { title: { display: true, text: content.data.y_label || 'Y' } }
                            }
                        }
                    });
                } catch (error) {
                    console.error('Error creating chart:', error);
                    this.renderError(graphDiv);
                }
                
                container.appendChild(graphDiv);
            }

            static renderDiagram(content, container) {
                const diagramDiv = document.createElement('div');
                diagramDiv.className = 'text-center';
                
                if (content.file && typeof content.file === 'string') {
                    const img = document.createElement('img');
                    img.src = `src/images/biology/diagrams/${content.file}`;
                    img.alt = content.alt_text || 'Diagram';
                    img.className = 'max-w-full h-auto mx-auto rounded-lg';
                    img.onerror = () => this.renderImageError(img);
                    diagramDiv.appendChild(img);
                } else {
                    this.renderError(diagramDiv);
                }
                
                container.appendChild(diagramDiv);
            }

            static renderAnimation(content, container) {
                const animDiv = document.createElement('div');
                animDiv.className = 'text-center';
                
                if (content.file && typeof content.file === 'string' && 
                    (content.format === 'gif' || content.format === 'mp4')) {
                    
                    const media = content.format === 'gif' ? 
                        document.createElement('img') : 
                        document.createElement('video');
                    
                    media.src = `src/images/biology/animations/${content.file}`;
                    media.className = 'max-w-full h-auto mx-auto rounded-lg';
                    
                    if (content.format === 'mp4' && media.tagName === 'VIDEO') {
                        media.controls = Boolean(content.controls);
                        media.autoplay = Boolean(content.autoplay);
                        media.loop = Boolean(content.loop);
                    }
                    
                    media.onerror = () => this.renderImageError(media);
                    animDiv.appendChild(media);
                } else {
                    this.renderError(animDiv);
                }
                
                container.appendChild(animDiv);
            }

            static renderDefault(content, container) {
                const defaultDiv = document.createElement('div');
                defaultDiv.className = 'bg-gray-100 dark:bg-gray-700 rounded-lg p-4 text-center';
                defaultDiv.innerHTML = `
                    <div class="text-4xl mb-2">üìä</div>
                    <p class="text-gray-600 dark:text-gray-400">Visual Content: ${content.file || content.type || 'Unknown'}</p>
                `;
                container.appendChild(defaultDiv);
            }

            static renderError(container) {
                container.innerHTML = `
                    <div class="bg-red-50 dark:bg-red-900/30 border border-red-200 dark:border-red-800 rounded-lg p-4 text-center">
                        <div class="text-2xl mb-2">‚ö†Ô∏è</div>
                        <p class="text-red-600 dark:text-red-400 text-sm">Error loading content</p>
                    </div>
                `;
            }

            static renderImageError(img) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'bg-gray-100 dark:bg-gray-700 rounded-lg p-4 text-center';
                errorDiv.innerHTML = `
                    <div class="text-2xl mb-2">üñºÔ∏è</div>
                    <p class="text-gray-600 dark:text-gray-400 text-sm">Image unavailable</p>
                `;
                if (img.parentNode) {
                    img.parentNode.replaceChild(errorDiv, img);
                }
            }
        }

        // Enhanced User Model with better type safety
        class UserModel {
            constructor() {
                this.knowledge_state = {};
                this.learning_style = {
                    prefers_visual: true,
                    prefers_text: false,
                    hint_usage: "medium"
                };
                this.behavioral_data = {
                    average_time_per_question: 35000,
                    common_mistakes: [],
                    confidence_rating: 0.5,
                    questions_answered: 0,
                    total_study_time: 0
                };
                this.session_data = [];
                
                // Initialize skill masteries
                Object.keys(skillDefinitions).forEach(skill => {
                    this.knowledge_state[skill] = {
                        mastery: 0.5,
                        exposure_count: 0,
                        last_correct: null,
                        last_accessed: null
                    };
                });
            }

            updateSkillMastery(skillId, isCorrect, timeSpent, confidence) {
                if (!skillId || typeof skillId !== 'string') {
                    console.warn('Invalid skillId provided to updateSkillMastery');
                    return;
                }

                if (!this.knowledge_state[skillId]) {
                    this.knowledge_state[skillId] = {
                        mastery: 0.5,
                        exposure_count: 0,
                        last_correct: null,
                        last_accessed: null
                    };
                }

                const skill = this.knowledge_state[skillId];
                skill.exposure_count++;
                skill.last_correct = Boolean(isCorrect);
                skill.last_accessed = new Date().toISOString();

                // Validate numeric inputs
                const validTimeSpent = Math.max(1000, Math.min(300000, Number(timeSpent) || 35000));
                const validConfidence = Math.max(0, Math.min(1, Number(confidence) || 0.5));

                // Adaptive mastery calculation
                const learningRate = 0.3;
                const confidenceWeight = 0.2;
                const timeWeight = 0.1;
                
                let adjustment = 0;
                if (isCorrect) {
                    adjustment = learningRate * (1 - skill.mastery) * (validConfidence * confidenceWeight + 0.8);
                } else {
                    adjustment = -learningRate * skill.mastery * 0.8;
                }

                // Time factor - slower answers indicate less certainty
                const expectedTime = 35000;
                const timeFactor = Math.max(0.5, Math.min(1.5, expectedTime / validTimeSpent));
                adjustment *= timeFactor * timeWeight + 0.9;

                skill.mastery = Math.max(0.1, Math.min(0.99, skill.mastery + adjustment));
            }

            getOverallMastery() {
                const skillEntries = Object.values(this.knowledge_state);
                if (skillEntries.length === 0) return 0;
                
                const masteries = skillEntries
                    .map(s => s && typeof s.mastery === 'number' ? s.mastery : 0.5)
                    .filter(m => m >= 0 && m <= 1);
                
                return masteries.length > 0 ? 
                    masteries.reduce((sum, m) => sum + m, 0) / masteries.length : 0.5;
            }

            getPredictedTimeToMastery() {
                const targetMastery = 0.8;
                const currentMastery = this.getOverallMastery();
                const learningRate = 0.05; // Questions per mastery point
                
                if (currentMastery >= targetMastery) return "Achieved!";
                
                const questionsNeeded = Math.ceil((targetMastery - currentMastery) / learningRate);
                const minutesNeeded = Math.ceil(questionsNeeded * 0.75); // ~45 seconds per question
                
                if (minutesNeeded < 60) return `${minutesNeeded} minutes`;
                return `${Math.ceil(minutesNeeded / 60)} hours`;
            }

            getInsights() {
                const insights = [];
                const totalQuestions = this.behavioral_data.questions_answered || 0;
                
                if (totalQuestions < 3) {
                    return ["Complete a few more questions to get personalized insights!"];
                }

                try {
                    // Performance insights
                    const masteries = Object.entries(this.knowledge_state)
                        .filter(([skillId]) => skillId && !skillId.includes('_BASIC'))
                        .map(([skillId, data]) => ({
                            skill: skillId,
                            mastery: (data && typeof data.mastery === 'number') ? data.mastery : 0.5,
                            name: skillDefinitions[skillId] || skillId
                        }))
                        .sort((a, b) => a.mastery - b.mastery);

                    if (masteries.length > 0) {
                        const weakest = masteries[0];
                        const strongest = masteries[masteries.length - 1];

                        if (weakest.mastery < 0.6) {
                            insights.push(`üéØ Focus Area: ${weakest.name} (${Math.round(weakest.mastery * 100)}% mastery)`);
                        }

                        if (strongest.mastery > 0.8) {
                            insights.push(`üåü Strength: ${strongest.name} (${Math.round(strongest.mastery * 100)}% mastery)`);
                        }
                    }

                    // Learning style insights
                    const avgTime = this.behavioral_data.average_time_per_question || 35000;
                    if (avgTime > 50000) {
                        insights.push("ü§î You take time to think deeply about questions - great for retention!");
                    } else if (avgTime < 25000) {
                        insights.push("‚ö° You're a quick thinker! Consider slowing down for complex questions.");
                    }

                    // Confidence insights
                    const confidence = this.behavioral_data.confidence_rating || 0.5;
                    if (confidence > 0.7) {
                        insights.push("üí™ You show high confidence in your answers - trust your knowledge!");
                    } else if (confidence < 0.4) {
                        insights.push("üéØ Building confidence is key - you know more than you think!");
                    }
                } catch (error) {
                    console.error('Error generating insights:', error);
                    insights.push("Unable to generate insights at this time.");
                }

                return insights.length > 0 ? insights : ["Keep up the great work! Your learning profile is developing nicely."];
            }
        }

        // Enhanced Adaptive Engine with better error handling
        class AdaptiveEngine {
            constructor(userModel) {
                if (!userModel) {
                    throw new Error('AdaptiveEngine requires a valid UserModel instance');
                }
                this.userModel = userModel;
                this.questionHistory = [];
                this.currentSessionQuestions = 0;
            }

            predictCorrectnessProbability(question) {
                if (!question || !Array.isArray(question.skills)) {
                    console.warn('Invalid question provided to predictCorrectnessProbability');
                    return 0.5;
                }

                try {
                    const userSkillMasteries = question.skills
                        .filter(skillId => skillId && this.userModel.knowledge_state[skillId])
                        .map(skillId => this.userModel.knowledge_state[skillId].mastery || 0.5);
                    
                    if (userSkillMasteries.length === 0) return 0.5;
                    
                    const avgSkillMastery = userSkillMasteries.reduce((sum, m) => sum + m, 0) / userSkillMasteries.length;
                    
                    const difficultyValue = (question.difficulty && typeof question.difficulty.value === 'number') 
                        ? question.difficulty.value : 3;
                    const difficultyFactor = (6 - difficultyValue) / 5;
                    
                    const guessProb = (typeof question.guess_probability === 'number') 
                        ? question.guess_probability : 0.25;
                    
                    const baseProb = avgSkillMastery * (1 - guessProb) + guessProb;
                    
                    return Math.min(0.95, Math.max(0.05, baseProb * difficultyFactor));
                } catch (error) {
                    console.error('Error calculating correctness probability:', error);
                    return 0.5;
                }
            }

            selectNextQuestion(targetSkills = null, goal = "efficiency") {
                if (!Array.isArray(questionBank) || questionBank.length === 0) {
                    console.error('No questions available in question bank');
                    return null;
                }

                let availableQuestions = questionBank.filter(q => 
                    q && q.id && !this.questionHistory.includes(q.id)
                );

                if (targetSkills && Array.isArray(targetSkills)) {
                    availableQuestions = availableQuestions.filter(q => 
                        Array.isArray(q.skills) && q.skills.some(skill => targetSkills.includes(skill))
                    );
                }

                if (availableQuestions.length === 0) {
                    this.questionHistory = [];
                    availableQuestions = questionBank.filter(q => q && q.id);
                }

                if (availableQuestions.length === 0) {
                    console.error('No valid questions found');
                    return null;
                }

                let selectedQuestion;

                try {
                    switch (goal) {
                        case "efficiency":
                            selectedQuestion = availableQuestions
                                .map(q => ({
                                    question: q,
                                    probability: this.predictCorrectnessProbability(q),
                                    score: 0
                                }))
                                .map(item => {
                                    const targetRange = [0.7, 0.85];
                                    if (item.probability >= targetRange[0] && item.probability <= targetRange[1]) {
                                        item.score = 100 - Math.abs(item.probability - 0.775) * 100;
                                    } else {
                                        item.score = Math.max(0, 50 - Math.abs(item.probability - 0.775) * 100);
                                    }
                                    return item;
                                })
                                .sort((a, b) => b.score - a.score)[0]?.question;
                            break;

                        case "remediation":
                            const commonMistakes = this.userModel.behavioral_data.common_mistakes || [];
                            selectedQuestion = availableQuestions
                                .filter(q => Array.isArray(q.skills) && q.skills.some(skill => 
                                    commonMistakes.includes(skill)
                                ))
                                .sort((a, b) => {
                                    const diffA = (a.difficulty && typeof a.difficulty.value === 'number') ? a.difficulty.value : 3;
                                    const diffB = (b.difficulty && typeof b.difficulty.value === 'number') ? b.difficulty.value : 3;
                                    return diffA - diffB;
                                })[0];
                            break;

                        case "assessment":
                            selectedQuestion = availableQuestions
                                .sort((a, b) => {
                                    const discA = (typeof a.discrimination_index === 'number') ? a.discrimination_index : 0.5;
                                    const discB = (typeof b.discrimination_index === 'number') ? b.discrimination_index : 0.5;
                                    return discB - discA;
                                })[0];
                            break;

                        default:
                            selectedQuestion = availableQuestions[0];
                    }
                } catch (error) {
                    console.error('Error selecting question:', error);
                    selectedQuestion = availableQuestions[0];
                }

                if (selectedQuestion && selectedQuestion.id) {
                    this.questionHistory.push(selectedQuestion.id);
                    this.currentSessionQuestions++;
                }

                return selectedQuestion || availableQuestions[0];
            }

            processAnswer(question, selectedOption, confidence, timeSpent) {
                if (!question || typeof selectedOption !== 'number' || selectedOption < 0) {
                    console.error('Invalid parameters provided to processAnswer');
                    return {
                        isCorrect: false,
                        explanation: "Invalid answer processing",
                        remediation: null,
                        skillUpdates: []
                    };
                }

                try {
                    const isCorrect = selectedOption === question.answer;

                    // Update skills safely
                    if (Array.isArray(question.skills)) {
                        question.skills.forEach(skillId => {
                            if (skillId && typeof skillId === 'string') {
                                this.userModel.updateSkillMastery(
                                    skillId, 
                                    isCorrect, 
                                    timeSpent || 35000, 
                                    (confidence || 50) / 100
                                );
                            }
                        });
                    }

                    // Update behavioral data safely
                    this.userModel.behavioral_data.questions_answered++;
                    
                    const validTimeSpent = Math.max(1000, Math.min(300000, Number(timeSpent) || 35000));
                    const questionsCount = this.userModel.behavioral_data.questions_answered;
                    
                    this.userModel.behavioral_data.average_time_per_question = 
                        (this.userModel.behavioral_data.average_time_per_question * (questionsCount - 1) + validTimeSpent) / questionsCount;
                    
                    const validConfidence = Math.max(0, Math.min(100, Number(confidence) || 50)) / 100;
                    this.userModel.behavioral_data.confidence_rating = 
                        (this.userModel.behavioral_data.confidence_rating * (questionsCount - 1) + validConfidence) / questionsCount;

                    // Handle misconceptions
                    if (!isCorrect && Array.isArray(question.common_misconceptions)) {
                        const misconception = question.common_misconceptions.find(m => 
                            m && m.option === selectedOption && m.skill_gap
                        );
                        if (misconception && misconception.skill_gap) {
                            const mistakes = this.userModel.behavioral_data.common_mistakes;
                            if (!mistakes.includes(misconception.skill_gap)) {
                                mistakes.push(misconception.skill_gap);
                            }
                        }
                    }

                    // Store session data
                    this.userModel.session_data.push({
                        questionId: question.id,
                        selectedOption,
                        isCorrect,
                        confidence: validConfidence * 100,
                        timeSpent: validTimeSpent,
                        timestamp: new Date().toISOString()
                    });

                    return {
                        isCorrect,
                        explanation: question.explanation || "No explanation available",
                        remediation: this.getRemediation(question, selectedOption),
                        skillUpdates: this.getSkillUpdates(question, isCorrect)
                    };
                } catch (error) {
                    console.error('Error processing answer:', error);
                    return {
                        isCorrect: false,
                        explanation: "Error processing answer",
                        remediation: null,
                        skillUpdates: []
                    };
                }
            }

            getRemediation(question, selectedOption) {
                if (!question || !Array.isArray(question.common_misconceptions)) {
                    return null;
                }

                try {
                    const misconception = question.common_misconceptions.find(m => 
                        m && m.option === selectedOption && m.remediation_id
                    );
                    
                    if (misconception && 
                        misconception.skill_gap && 
                        misconception.remediation_id &&
                        remediationContent[misconception.remediation_id]) {
                        
                        return {
                            skillGap: skillDefinitions[misconception.skill_gap] || misconception.skill_gap,
                            content: remediationContent[misconception.remediation_id]
                        };
                    }
                } catch (error) {
                    console.error('Error getting remediation:', error);
                }
                
                return null;
            }

            getSkillUpdates(question, isCorrect) {
                if (!question || !Array.isArray(question.skills)) {
                    return [];
                }

                try {
                    return question.skills
                        .filter(skillId => skillId && this.userModel.knowledge_state[skillId])
                        .map(skillId => ({
                            skill: skillDefinitions[skillId] || skillId,
                            previousMastery: this.userModel.knowledge_state[skillId].mastery,
                            change: isCorrect ? "improved" : "needs work"
                        }));
                } catch (error) {
                    console.error('Error getting skill updates:', error);
                    return [];
                }
            }
        }

        // Enhanced Learning App with comprehensive error handling
        class LearningApp {
            constructor() {
                try {
                    this.userModel = new UserModel();
                    this.adaptiveEngine = new AdaptiveEngine(this.userModel);
                    this.currentQuestion = null;
                    this.questionStartTime = null;
                    this.selectedOption = null;
                    this.hintAttempts = 0;
                    
                    this.initializeEventListeners();
                    this.updateDashboard();
                } catch (error) {
                    console.error('Error initializing LearningApp:', error);
                    this.showError('Failed to initialize the learning application. Please refresh the page.');
                }
            }

            initializeEventListeners() {
                // Add all event listeners with error handling
                addEventListenerSafe(getElement('start-learning'), 'click', () => this.startLearning());
                addEventListenerSafe(getElement('back-to-dashboard'), 'click', () => this.showDashboard());
                addEventListenerSafe(getElement('view-analytics'), 'click', () => this.showDashboard());
                addEventListenerSafe(getElement('submit-answer'), 'click', () => this.submitAnswer());
                addEventListenerSafe(getElement('hint-button'), 'click', () => this.showHint());
                addEventListenerSafe(getElement('next-question'), 'click', () => this.nextQuestion());

                const confidenceSlider = getElement('confidence-slider');
                addEventListenerSafe(confidenceSlider, 'input', (e) => {
                    const confidenceValue = getElement('confidence-value');
                    if (confidenceValue && e.target && e.target.value) {
                        confidenceValue.textContent = e.target.value + '%';
                    }
                });
            }

            showDashboard() {
                try {
                    this.setViewVisibility('dashboard-view', true);
                    this.setViewVisibility('question-view', false);
                    this.setViewVisibility('feedback-view', false);
                    this.updateDashboard();
                } catch (error) {
                    console.error('Error showing dashboard:', error);
                }
            }

            setViewVisibility(viewId, isVisible) {
                const element = getElement(viewId);
                if (element) {
                    if (isVisible) {
                        element.classList.remove('hidden');
                    } else {
                        element.classList.add('hidden');
                    }
                }
            }

            updateDashboard() {
                try {
                    // Update stats safely
                    this.updateElementText('total-mastery', Math.round(this.userModel.getOverallMastery() * 100) + '%');
                    this.updateElementText('questions-answered', String(this.userModel.behavioral_data.questions_answered));
                    this.updateElementText('predicted-time', this.userModel.getPredictedTimeToMastery());

                    // Update skills breakdown
                    const skillsContainer = getElement('skills-breakdown');
                    if (skillsContainer) {
                        skillsContainer.innerHTML = '';
                        
                        Object.entries(this.userModel.knowledge_state)
                            .filter(([skillId]) => skillId && !skillId.includes('_BASIC'))
                            .forEach(([skillId, data]) => {
                                if (data && typeof data.mastery === 'number') {
                                    const skillDiv = document.createElement('div');
                                    const mastery = Math.round(data.mastery * 100);
                                    const skillName = skillDefinitions[skillId] || skillId;
                                    
                                    skillDiv.innerHTML = `
                                        <div class="flex justify-between items-center mb-1">
                                            <span class="text-sm font-medium">${skillName}</span>
                                            <span class="text-sm text-gray-600 dark:text-gray-400">${mastery}%</span>
                                        </div>
                                        <div class="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2">
                                            <div class="mastery-bar bg-primary h-2 rounded-full" style="width: ${mastery}%"></div>
                                        </div>
                                    `;
                                    skillsContainer.appendChild(skillDiv);
                                }
                            });
                    }

                    // Update insights
                    const insights = this.userModel.getInsights();
                    const insightsContainer = getElement('learning-insights');
                    if (insightsContainer && Array.isArray(insights)) {
                        insightsContainer.innerHTML = insights
                            .map(insight => `<p class="mb-2">${insight}</p>`)
                            .join('');
                    }
                } catch (error) {
                    console.error('Error updating dashboard:', error);
                }
            }

            updateElementText(elementId, text) {
                const element = getElement(elementId, false);
                if (element) {
                    element.textContent = String(text);
                }
            }

            startLearning() {
                try {
                    const nextQuestion = this.adaptiveEngine.selectNextQuestion();
                    if (nextQuestion) {
                        this.loadQuestion(nextQuestion);
                    } else {
                        this.showError('No questions available. Please try again later.');
                    }
                } catch (error) {
                    console.error('Error starting learning:', error);
                    this.showError('Failed to load question. Please try again.');
                }
            }

            loadQuestion(question) {
                try {
                    if (!question || !question.id) {
                        this.showError('Invalid question data');
                        return;
                    }

                    this.currentQuestion = question;
                    this.questionStartTime = Date.now();
                    this.selectedOption = null;
                    this.hintAttempts = 0;

                    this.setViewVisibility('dashboard-view', false);
                    this.setViewVisibility('feedback-view', false);
                    this.setViewVisibility('question-view', true);

                    // Update question info
                    this.updateElementText('current-question', String(this.adaptiveEngine.currentSessionQuestions));
                    this.updateElementText('question-difficulty', 
                        (question.difficulty && question.difficulty.value) ? String(question.difficulty.value) : '3'
                    );
                    this.updateElementText('question-source', question.source || 'Unknown');
                    this.updateElementText('question-text', question.question || 'Question not available');

                    // Handle visual content
                    const visualElement = getElement('question-visual');
                    if (question.visual_content && visualElement) {
                        visualElement.classList.remove('hidden');
                        const container = getElement('visual-content-container');
                        if (container) {
                            VisualContentRenderer.render(question.visual_content, container);
                        }
                    } else if (visualElement) {
                        visualElement.classList.add('hidden');
                    }

                    // Render options
                    this.renderQuestionOptions(question);

                    // Handle hints
                    const hintsSection = getElement('hints-section');
                    if (hintsSection) {
                        if (Array.isArray(question.hints) && question.hints.length > 0) {
                            hintsSection.classList.remove('hidden');
                            const hintText = getElement('hint-text');
                            if (hintText) {
                                hintText.classList.add('hidden');
                            }
                        } else {
                            hintsSection.classList.add('hidden');
                        }
                    }

                    // Reset confidence slider
                    const confidenceSlider = getElement('confidence-slider');
                    if (confidenceSlider) {
                        confidenceSlider.value = '50';
                        this.updateElementText('confidence-value', '50%');
                    }

                    // Update progress bar
                    const progressBar = getElement('progress-bar');
                    if (progressBar) {
                        const progress = (this.adaptiveEngine.currentSessionQuestions / 10) * 100;
                        progressBar.style.width = Math.min(100, progress) + '%';
                    }
                } catch (error) {
                    console.error('Error loading question:', error);
                    this.showError('Failed to load question content');
                }
            }

            renderQuestionOptions(question) {
                const optionsContainer = getElement('question-options');
                if (!optionsContainer || !Array.isArray(question.options)) {
                    console.error('Cannot render question options');
                    return;
                }

                optionsContainer.innerHTML = '';
                
                question.options.forEach((option, index) => {
                    if (typeof option !== 'string') return;
                    
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'question-option p-4 border border-gray-200 dark:border-gray-600 rounded-lg cursor-pointer hover:border-primary transition-colors';
                    
                    // Check if option contains LaTeX
                    if (option.includes('$')) {
                        optionDiv.innerHTML = `
                            <div class="flex items-center">
                                <div class="w-6 h-6 border-2 border-gray-300 dark:border-gray-500 rounded-full mr-3 flex items-center justify-center">
                                    <div class="w-3 h-3 bg-primary rounded-full hidden option-selected"></div>
                                </div>
                                <span class="text-base">${String.fromCharCode(65 + index)}. ${option}</span>
                            </div>
                        `;
                        // Render LaTeX in options
                        if (window.MathJax && typeof window.MathJax.typesetPromise === 'function') {
                            window.MathJax.typesetPromise([optionDiv]).catch(err => {
                                console.error('MathJax error:', err);
                            });
                        }
                    } else {
                        optionDiv.innerHTML = `
                            <div class="flex items-center">
                                <div class="w-6 h-6 border-2 border-gray-300 dark:border-gray-500 rounded-full mr-3 flex items-center justify-center">
                                    <div class="w-3 h-3 bg-primary rounded-full hidden option-selected"></div>
                                </div>
                                <span class="text-base">${String.fromCharCode(65 + index)}. ${option}</span>
                            </div>
                        `;
                    }
                    
                    addEventListenerSafe(optionDiv, 'click', () => this.selectOption(index, optionDiv));
                    optionsContainer.appendChild(optionDiv);
                });
            }

            selectOption(index, optionElement) {
                try {
                    // Clear previous selections
                    const allOptions = document.querySelectorAll('.question-option');
                    allOptions.forEach(el => {
                        el.classList.remove('border-primary', 'bg-primary/10');
                        const selectedIndicator = el.querySelector('.option-selected');
                        if (selectedIndicator) {
                            selectedIndicator.classList.add('hidden');
                        }
                    });

                    // Set current selection
                    this.selectedOption = index;
                    if (optionElement) {
                        optionElement.classList.add('border-primary', 'bg-primary/10');
                        const selectedIndicator = optionElement.querySelector('.option-selected');
                        if (selectedIndicator) {
                            selectedIndicator.classList.remove('hidden');
                        }
                    }

                    // Enable submit button
                    const submitButton = getElement('submit-answer');
                    if (submitButton) {
                        submitButton.disabled = false;
                    }
                } catch (error) {
                    console.error('Error selecting option:', error);
                }
            }

            showHint() {
                try {
                    if (!this.currentQuestion || 
                        !Array.isArray(this.currentQuestion.hints) || 
                        this.hintAttempts >= this.currentQuestion.hints.length) {
                        return;
                    }

                    const hint = this.currentQuestion.hints[this.hintAttempts];
                    if (hint && hint.text) {
                        const hintText = getElement('hint-text');
                        const hintButton = getElement('hint-button');
                        
                        if (hintText) {
                            hintText.textContent = hint.text;
                            hintText.classList.remove('hidden');
                        }
                        
                        this.hintAttempts++;
                        
                        if (hintButton) {
                            if (this.hintAttempts >= this.currentQuestion.hints.length) {
                                hintButton.classList.add('hidden');
                            } else {
                                hintButton.textContent = `üí° Show another hint (${this.hintAttempts}/${this.currentQuestion.hints.length})`;
                            }
                        }
                        
                        this.userModel.learning_style.hint_usage = "high";
                    }
                } catch (error) {
                    console.error('Error showing hint:', error);
                }
            }

            submitAnswer() {
                try {
                    if (this.selectedOption === null || !this.currentQuestion || !this.questionStartTime) {
                        console.warn('Cannot submit: missing required data');
                        return;
                    }

                    const timeSpent = Date.now() - this.questionStartTime;
                    const confidenceSlider = getElement('confidence-slider');
                    const confidence = confidenceSlider ? parseInt(confidenceSlider.value) || 50 : 50;

                    const result = this.adaptiveEngine.processAnswer(
                        this.currentQuestion,
                        this.selectedOption,
                        confidence,
                        timeSpent
                    );

                    if (result) {
                        this.showFeedback(result);
                    } else {
                        this.showError('Failed to process answer');
                    }
                } catch (error) {
                    console.error('Error submitting answer:', error);
                    this.showError('Failed to submit answer');
                }
            }

            showFeedback(result) {
                try {
                    this.setViewVisibility('question-view', false);
                    this.setViewVisibility('feedback-view', true);

                    // Set feedback header
                    if (result.isCorrect) {
                        this.updateElementText('feedback-icon', 'üéâ');
                        this.updateElementText('feedback-title', 'Correct!');
                        this.updateElementText('feedback-subtitle', 'Great job! You\'re mastering this concept.');
                    } else {
                        this.updateElementText('feedback-icon', 'ü§î');
                        this.updateElementText('feedback-title', 'Not quite right');
                        this.updateElementText('feedback-subtitle', 'Let\'s learn from this mistake.');
                    }

                    // Show explanation
                    const explanationDiv = getElement('feedback-explanation');
                    if (explanationDiv && result.explanation) {
                        explanationDiv.innerHTML = `
                            <h4 class="font-semibold mb-2">Explanation:</h4>
                            <p>${result.explanation}</p>
                        `;
                        
                        // Render LaTeX in explanation if present
                        if (result.explanation.includes('$') && window.MathJax && typeof window.MathJax.typesetPromise === 'function') {
                            window.MathJax.typesetPromise([explanationDiv]).catch(err => {
                                console.error('MathJax error:', err);
                            });
                        }
                    }

                    // Show remediation if available
                    const remediationSection = getElement('remediation-section');
                    const remediationContent = getElement('remediation-content');
                    
                    if (result.remediation && remediationSection && remediationContent) {
                        remediationSection.classList.remove('hidden');
                        remediationContent.innerHTML = `
                            <h5 class="font-medium mb-2">Concept to Review: ${result.remediation.skillGap}</h5>
                            <p>${result.remediation.content}</p>
                        `;
                    } else if (remediationSection) {
                        remediationSection.classList.add('hidden');
                    }

                    // Show skill updates
                    const skillUpdateSection = getElement('skill-update');
                    const skillChanges = getElement('skill-changes');
                    
                    if (Array.isArray(result.skillUpdates) && result.skillUpdates.length > 0 && skillUpdateSection && skillChanges) {
                        skillUpdateSection.classList.remove('hidden');
                        skillChanges.innerHTML = result.skillUpdates
                            .map(update => `
                                <div class="flex items-center justify-between py-2">
                                    <span>${update.skill || 'Unknown Skill'}</span>
                                    <span class="text-sm ${update.change === 'improved' ? 'text-green-600 dark:text-green-400' : 'text-orange-600 dark:text-orange-400'}">
                                        ${update.change === 'improved' ? 'üìà Improved' : 'üìä Needs work'}
                                    </span>
                                </div>
                            `).join('');
                    } else if (skillUpdateSection) {
                        skillUpdateSection.classList.add('hidden');
                    }
                } catch (error) {
                    console.error('Error showing feedback:', error);
                    this.showError('Failed to display feedback');
                }
            }

            nextQuestion() {
                try {
                    const nextQuestion = this.adaptiveEngine.selectNextQuestion();
                    if (nextQuestion) {
                        this.loadQuestion(nextQuestion);
                    } else {
                        this.showError('No more questions available');
                        this.showDashboard();
                    }
                } catch (error) {
                    console.error('Error loading next question:', error);
                    this.showError('Failed to load next question');
                }
            }

            showError(message) {
                console.error('Application Error:', message);
                // Create a simple error display - avoid using alert()
                const errorDiv = document.createElement('div');
                errorDiv.className = 'fixed top-4 right-4 bg-red-500 text-white p-4 rounded-lg shadow-lg z-50';
                errorDiv.innerHTML = `
                    <div class="flex items-center justify-between">
                        <span>${message}</span>
                        <button class="ml-4 text-white hover:text-gray-200" onclick="this.parentElement.parentElement.remove()">√ó</button>
                    </div>
                `;
                document.body.appendChild(errorDiv);
                
                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (errorDiv.parentNode) {
                        errorDiv.parentNode.removeChild(errorDiv);
                    }
                }, 5000);
            }
        }

        // Initialize the app with error handling
        try {
            const app = new LearningApp();
        } catch (error) {
            console.error('Failed to initialize application:', error);
            document.body.innerHTML = `
                <div class="flex items-center justify-center min-h-screen bg-gray-100 dark:bg-gray-900">
                    <div class="text-center p-8">
                        <h1 class="text-2xl font-bold text-red-600 mb-4">Application Error</h1>
                        <p class="text-gray-700 dark:text-gray-300 mb-4">Failed to load the learning application.</p>
                        <button onclick="window.location.reload()" class="bg-primary text-white px-4 py-2 rounded hover:bg-primary-dark">
                            Reload Page
                        </button>
                    </div>
                </div>
            `;
        }
    </script>
</body>
</html>
