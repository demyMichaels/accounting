<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bounce Lab - Kinetic Energy Physics Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        secondary: '#00D4AA',
                        accent: '#FF6B6B'
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            font-family: 'Inter', sans-serif;
        }
        
        .glow {
            box-shadow: 0 0 20px rgba(93, 92, 222, 0.3);
        }
        
        .trajectory-dot {
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        .energy-meter {
            background: linear-gradient(90deg, #FF6B6B 0%, #4ECDC4 50%, #45B7D1 100%);
        }
        
        .ball-trail {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0.3;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-white transition-colors min-h-screen">
    <!-- Game Container -->
    <div class="flex flex-col h-screen max-w-md mx-auto bg-gray-50 dark:bg-gray-800 relative overflow-hidden">
        
        <!-- Header HUD -->
        <div class="bg-white dark:bg-gray-900 shadow-lg p-4 z-10">
            <div class="flex justify-between items-center mb-3">
                <h1 class="text-xl font-bold text-primary">Bounce Lab</h1>
                <div class="flex items-center space-x-4">
                    <button id="soundToggle" class="text-2xl">üîä</button>
                    <div class="text-sm">
                        <span class="text-gray-600 dark:text-gray-400">Level:</span>
                        <span id="currentLevel" class="font-bold text-primary">1</span>
                    </div>
                </div>
            </div>
            
            <!-- Target KE Display -->
            <div class="bg-gradient-to-r from-primary/10 to-secondary/10 rounded-lg p-3 mb-3">
                <div class="flex justify-between items-center">
                    <span class="text-sm font-medium">Target KE:</span>
                    <span id="targetKE" class="font-bold text-lg">20 J</span>
                </div>
                <div class="flex justify-between items-center mt-1">
                    <span class="text-sm font-medium">Current KE:</span>
                    <span id="currentKE" class="font-bold text-lg text-primary">0 J</span>
                </div>
            </div>
            
            <!-- Controls -->
            <div class="grid grid-cols-2 gap-3">
                <!-- Mass Control -->
                <div class="bg-white dark:bg-gray-800 rounded-lg p-3">
                    <label class="text-xs font-medium text-gray-600 dark:text-gray-400 block mb-2">Mass (kg)</label>
                    <div class="flex items-center justify-between">
                        <button id="massDown" class="w-8 h-8 bg-gray-200 dark:bg-gray-700 rounded-full flex items-center justify-center text-sm font-bold">-</button>
                        <span id="massValue" class="font-bold text-lg">5</span>
                        <button id="massUp" class="w-8 h-8 bg-gray-200 dark:bg-gray-700 rounded-full flex items-center justify-center text-sm font-bold">+</button>
                    </div>
                </div>
                
                <!-- Velocity Display -->
                <div class="bg-white dark:bg-gray-800 rounded-lg p-3">
                    <label class="text-xs font-medium text-gray-600 dark:text-gray-400 block mb-2">Velocity (m/s)</label>
                    <div class="text-center">
                        <span id="velocityValue" class="font-bold text-lg">0</span>
                        <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2 mt-1">
                            <div id="velocityBar" class="energy-meter h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Game Canvas -->
        <div class="flex-1 relative">
            <canvas id="gameCanvas" class="w-full h-full bg-gradient-to-b from-blue-50 to-green-50 dark:from-gray-800 dark:to-gray-900"></canvas>
            
            <!-- Launch Instructions -->
            <div id="instructions" class="absolute inset-0 flex items-center justify-center pointer-events-none">
                <div class="bg-black/80 text-white p-4 rounded-lg text-center max-w-xs">
                    <h3 class="font-bold mb-2">How to Play:</h3>
                    <p class="text-sm">1. Adjust mass with +/- buttons</p>
                    <p class="text-sm">2. Drag from cannon to set velocity</p>
                    <p class="text-sm">3. Release to launch!</p>
                    <p class="text-xs text-yellow-300 mt-2">Hit the target with exact KE!</p>
                </div>
            </div>
        </div>
        
        <!-- Educational Popup -->
        <div id="educationModal" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 hidden">
            <div class="bg-white dark:bg-gray-800 rounded-lg p-6 m-4 max-w-sm">
                <h3 id="modalTitle" class="font-bold text-lg mb-3"></h3>
                <p id="modalContent" class="text-sm text-gray-600 dark:text-gray-400 mb-4"></p>
                <div id="modalFormula" class="bg-primary/10 rounded-lg p-3 mb-4 font-mono text-sm"></div>
                <button id="modalClose" class="w-full bg-primary text-white py-2 rounded-lg font-medium">Continue</button>
            </div>
        </div>
        
        <!-- Level Complete -->
        <div id="levelComplete" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 hidden">
            <div class="bg-white dark:bg-gray-800 rounded-lg p-6 m-4 max-w-sm text-center">
                <div class="text-6xl mb-4">üéâ</div>
                <h3 class="font-bold text-xl mb-2">Level Complete!</h3>
                <div id="stars" class="text-3xl mb-4">‚≠ê‚≠ê‚≠ê</div>
                <p id="performance" class="text-sm text-gray-600 dark:text-gray-400 mb-4"></p>
                <button id="nextLevel" class="w-full bg-primary text-white py-3 rounded-lg font-medium">Next Level</button>
            </div>
        </div>
    </div>

    <script>
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Type definitions using JSDoc for better TypeScript-like behavior
        
        /**
         * @typedef {Object} Vector2D
         * @property {number} x
         * @property {number} y
         */
        
        /**
         * @typedef {Object} GameTarget
         * @property {number} x
         * @property {number} y
         * @property {number} size
         */
        
        /**
         * @typedef {Object} GameObstacle
         * @property {number} x
         * @property {number} y
         * @property {number} width
         * @property {number} height
         */
        
        /**
         * @typedef {Object} GameBall
         * @property {Matter.Body} body
         * @property {number} mass
         * @property {number} radius
         * @property {number} ke
         * @property {number} initialKE
         */
        
        /**
         * @typedef {Object} Trail
         * @property {number} x
         * @property {number} y
         * @property {number} size
         * @property {number} alpha
         * @property {number} life
         */
        
        /**
         * @typedef {Object} LevelConfig
         * @property {number} targetKE
         * @property {GameTarget[]} targets
         * @property {GameObstacle[]} obstacles
         */

        // Sound System with proper typing
        class SoundSystem {
            /** @type {AudioContext | null} */
            audioContext = null;
            /** @type {boolean} */
            enabled = true;
            
            constructor() {
                this.setupAudio();
            }
            
            setupAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Web Audio API not supported');
                    this.enabled = false;
                }
            }
            
            /**
             * @param {number} frequency
             * @param {number} duration
             * @param {OscillatorType} type
             * @param {number} volume
             */
            playTone(frequency, duration, type = 'sine', volume = 0.3) {
                if (!this.enabled || !this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(volume, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            playLaunch() {
                // Rising whoosh sound
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        this.playTone(200 + i * 50, 0.1, 'sawtooth', 0.2);
                    }, i * 20);
                }
            }
            
            /** @param {number} velocity */
            playBounce(velocity) {
                // Pop sound with frequency based on velocity
                const frequency = Math.max(150, Math.min(800, velocity * 100));
                this.playTone(frequency, 0.15, 'square', 0.3);
            }
            
            /** @param {boolean} success */
            playHit(success) {
                if (success) {
                    // Success chord
                    this.playTone(523, 0.3); // C
                    setTimeout(() => this.playTone(659, 0.3), 100); // E
                    setTimeout(() => this.playTone(784, 0.5), 200); // G
                } else {
                    // Miss sound
                    this.playTone(150, 0.2, 'sawtooth', 0.2);
                }
            }
            
            playLevelComplete() {
                // Victory fanfare
                const notes = [523, 659, 784, 1047]; // C, E, G, C
                notes.forEach((note, i) => {
                    setTimeout(() => this.playTone(note, 0.4), i * 150);
                });
            }
            
            /** @returns {boolean} */
            toggle() {
                this.enabled = !this.enabled;
                return this.enabled;
            }
        }

        // Game State with proper typing
        class BounceLabGame {
            /** @type {HTMLCanvasElement} */
            canvas;
            /** @type {CanvasRenderingContext2D} */
            ctx;
            /** @type {Matter.Engine} */
            engine;
            /** @type {Matter.World} */
            world;
            /** @type {SoundSystem} */
            sound;
            
            // Game state
            /** @type {number} */
            currentLevel = 1;
            /** @type {number} */
            mass = 5;
            /** @type {number} */
            velocity = 0;
            /** @type {number} */
            maxVelocity = 20;
            /** @type {number} */
            scale = 10;
            /** @type {number} */
            targetKE = 0;
            
            // Physics objects
            /** @type {GameBall[]} */
            balls = [];
            /** @type {Matter.Body[]} */
            ballBodies = [];
            /** @type {GameTarget[]} */
            targets = [];
            /** @type {GameObstacle[]} */
            obstacles = [];
            /** @type {Matter.Body[]} */
            obstacleBodies = [];
            /** @type {Trail[]} */
            trails = [];
            /** @type {Matter.Body[]} */
            boundaries = [];
            
            // Input state
            /** @type {boolean} */
            isDragging = false;
            /** @type {Vector2D} */
            dragStart = { x: 0, y: 0 };
            /** @type {Vector2D} */
            dragCurrent = { x: 0, y: 0 };
            /** @type {Vector2D} */
            cannonPos = { x: 100, y: 0 };
            
            // Game timing
            /** @type {number} */
            lastTime = 0;
            /** @type {boolean} */
            gameRunning = false;
            /** @type {number} */
            canvasWidth = 0;
            /** @type {number} */
            canvasHeight = 0;
            
            constructor() {
                const canvas = document.getElementById('gameCanvas');
                const ctx = canvas?.getContext('2d');
                
                if (!canvas || !ctx) {
                    throw new Error('Canvas or context not found');
                }
                
                this.canvas = canvas;
                this.ctx = ctx;
                this.setupCanvas();
                
                // Initialize Matter.js
                this.engine = Matter.Engine.create();
                this.world = this.engine.world;
                this.engine.world.gravity.y = 0.8; // Adjusted for canvas scale
                
                // Sound system
                this.sound = new SoundSystem();
                
                this.setupPhysics();
                this.setupLevel();
                this.setupControls();
                this.setupEventListeners();
                this.gameLoop();
            }
            
            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                
                this.cannonPos.y = rect.height - 100;
                this.canvasWidth = rect.width;
                this.canvasHeight = rect.height;
            }
            
            setupPhysics() {
                // Create boundaries
                const thickness = 50;
                this.boundaries = [
                    // Bottom
                    Matter.Bodies.rectangle(this.canvasWidth / 2, this.canvasHeight + thickness / 2, this.canvasWidth, thickness, { isStatic: true }),
                    // Left
                    Matter.Bodies.rectangle(-thickness / 2, this.canvasHeight / 2, thickness, this.canvasHeight, { isStatic: true }),
                    // Right
                    Matter.Bodies.rectangle(this.canvasWidth + thickness / 2, this.canvasHeight / 2, thickness, this.canvasHeight, { isStatic: true }),
                    // Top (optional, for very high shots)
                    Matter.Bodies.rectangle(this.canvasWidth / 2, -thickness / 2, this.canvasWidth, thickness, { isStatic: true })
                ];
                
                Matter.World.add(this.world, this.boundaries);
                
                // Collision detection
                Matter.Events.on(this.engine, 'collisionStart', (event) => {
                    event.pairs.forEach((pair) => {
                        const { bodyA, bodyB } = pair;
                        
                        // Check for ball collisions
                        const ball = this.ballBodies.find(b => b === bodyA || b === bodyB);
                        if (ball) {
                            const velocity = Math.sqrt(ball.velocity.x ** 2 + ball.velocity.y ** 2);
                            if (velocity > 2) {
                                this.sound.playBounce(velocity);
                            }
                        }
                    });
                });
            }
            
            setupLevel() {
                // Clear existing physics bodies
                this.ballBodies.forEach(body => Matter.World.remove(this.world, body));
                this.obstacleBodies.forEach(body => Matter.World.remove(this.world, body));
                this.ballBodies = [];
                this.balls = [];
                this.obstacleBodies = [];
                this.trails = [];
                
                /** @type {LevelConfig[]} */
                const levels = [
                    { targetKE: 20, targets: [{ x: 300, y: 200, size: 30 }], obstacles: [] },
                    { targetKE: 50, targets: [{ x: 350, y: 150, size: 25 }], obstacles: [{ x: 200, y: 300, width: 20, height: 100 }] },
                    { targetKE: 100, targets: [{ x: 400, y: 100, size: 35 }], obstacles: [{ x: 150, y: 250, width: 100, height: 20 }, { x: 300, y: 180, width: 20, height: 80 }] },
                    { targetKE: 200, targets: [{ x: 450, y: 80, size: 40 }], obstacles: [{ x: 180, y: 200, width: 120, height: 15 }, { x: 350, y: 300, width: 15, height: 100 }] },
                    { targetKE: 150, targets: [{ x: 200, y: 100, size: 25 }, { x: 400, y: 200, size: 30 }], obstacles: [] }
                ];
                
                const level = levels[Math.min(this.currentLevel - 1, levels.length - 1)];
                this.targetKE = level.targetKE;
                this.targets = level.targets;
                this.obstacles = level.obstacles;
                
                // Create obstacle physics bodies
                this.obstacles.forEach(obstacle => {
                    const body = Matter.Bodies.rectangle(
                        obstacle.x + obstacle.width / 2,
                        obstacle.y + obstacle.height / 2,
                        obstacle.width,
                        obstacle.height,
                        { 
                            isStatic: true,
                            restitution: 0.8,
                            friction: 0.3
                        }
                    );
                    this.obstacleBodies.push(body);
                    Matter.World.add(this.world, body);
                });
                
                this.updateUIElements();
            }
            
            updateUIElements() {
                const currentLevelEl = document.getElementById('currentLevel');
                const targetKEEl = document.getElementById('targetKE');
                
                if (currentLevelEl) currentLevelEl.textContent = this.currentLevel.toString();
                if (targetKEEl) targetKEEl.textContent = `${this.targetKE} J`;
                this.updateKE();
            }
            
            setupControls() {
                const massDown = document.getElementById('massDown');
                const massUp = document.getElementById('massUp');
                const soundToggle = document.getElementById('soundToggle');
                const modalClose = document.getElementById('modalClose');
                const nextLevel = document.getElementById('nextLevel');
                
                massDown?.addEventListener('click', () => {
                    this.mass = Math.max(1, this.mass - 1);
                    this.updateMass();
                });
                
                massUp?.addEventListener('click', () => {
                    this.mass = Math.min(10, this.mass + 1);
                    this.updateMass();
                });
                
                soundToggle?.addEventListener('click', () => {
                    const enabled = this.sound.toggle();
                    if (soundToggle) soundToggle.textContent = enabled ? 'üîä' : 'üîá';
                });
                
                modalClose?.addEventListener('click', () => {
                    const modal = document.getElementById('educationModal');
                    modal?.classList.add('hidden');
                });
                
                nextLevel?.addEventListener('click', () => {
                    this.currentLevel++;
                    this.setupLevel();
                    const levelCompleteModal = document.getElementById('levelComplete');
                    const instructions = document.getElementById('instructions');
                    levelCompleteModal?.classList.add('hidden');
                    instructions?.classList.remove('hidden');
                });
            }
            
            setupEventListeners() {
                // Touch events
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    if (touch) {
                        const rect = this.canvas.getBoundingClientRect();
                        this.startDrag(touch.clientX - rect.left, touch.clientY - rect.top);
                    }
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    if (touch) {
                        const rect = this.canvas.getBoundingClientRect();
                        this.updateDrag(touch.clientX - rect.left, touch.clientY - rect.top);
                    }
                });
                
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.endDrag();
                });
                
                // Mouse events for desktop
                this.canvas.addEventListener('mousedown', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.startDrag(e.clientX - rect.left, e.clientY - rect.top);
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        const rect = this.canvas.getBoundingClientRect();
                        this.updateDrag(e.clientX - rect.left, e.clientY - rect.top);
                    }
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.endDrag();
                });
            }
            
            /** @param {number} x @param {number} y */
            startDrag(x, y) {
                const distance = Math.sqrt((x - this.cannonPos.x) ** 2 + (y - this.cannonPos.y) ** 2);
                if (distance < 50 && this.ballBodies.length === 0) {
                    this.isDragging = true;
                    this.dragStart = { x, y };
                    this.dragCurrent = { x, y };
                    const instructions = document.getElementById('instructions');
                    instructions?.classList.add('hidden');
                }
            }
            
            /** @param {number} x @param {number} y */
            updateDrag(x, y) {
                if (this.isDragging) {
                    this.dragCurrent = { x, y };
                    const dx = this.dragStart.x - x;
                    const dy = this.dragStart.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    this.velocity = Math.min(this.maxVelocity, distance / 10);
                    this.updateKE();
                }
            }
            
            endDrag() {
                if (this.isDragging && this.velocity > 0) {
                    this.launchBall();
                }
                this.isDragging = false;
                this.velocity = 0;
                this.updateKE();
            }
            
            launchBall() {
                const dx = this.dragStart.x - this.dragCurrent.x;
                const dy = this.dragStart.y - this.dragCurrent.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    const vx = (dx / distance) * this.velocity;
                    const vy = (dy / distance) * this.velocity;
                    
                    const radius = Math.sqrt(this.mass) * 3 + 5;
                    
                    // Create Matter.js body
                    const ballBody = Matter.Bodies.circle(
                        this.cannonPos.x,
                        this.cannonPos.y,
                        radius,
                        {
                            restitution: 0.8,
                            friction: 0.3,
                            density: this.mass / (Math.PI * radius * radius)
                        }
                    );
                    
                    // Set initial velocity
                    Matter.Body.setVelocity(ballBody, { x: vx, y: vy });
                    
                    /** @type {GameBall} */
                    const ball = {
                        body: ballBody,
                        mass: this.mass,
                        radius: radius,
                        ke: 0.5 * this.mass * this.velocity * this.velocity,
                        initialKE: 0.5 * this.mass * this.velocity * this.velocity
                    };
                    
                    this.balls.push(ball);
                    this.ballBodies.push(ballBody);
                    Matter.World.add(this.world, ballBody);
                    
                    this.gameRunning = true;
                    this.sound.playLaunch();
                    
                    // Show educational popup
                    this.showEducationModal(ball.ke);
                }
            }
            
            updateMass() {
                const massValueEl = document.getElementById('massValue');
                if (massValueEl) massValueEl.textContent = this.mass.toString();
                this.updateKE();
            }
            
            updateKE() {
                const ke = 0.5 * this.mass * this.velocity * this.velocity;
                const currentKEEl = document.getElementById('currentKE');
                const velocityValueEl = document.getElementById('velocityValue');
                const velocityBarEl = document.getElementById('velocityBar');
                
                if (currentKEEl) currentKEEl.textContent = `${Math.round(ke)} J`;
                if (velocityValueEl) velocityValueEl.textContent = Math.round(this.velocity).toString();
                if (velocityBarEl) velocityBarEl.style.width = `${(this.velocity / this.maxVelocity) * 100}%`;
            }
            
            /** @param {number} actualKE */
            showEducationModal(actualKE) {
                const modal = document.getElementById('educationModal');
                const modalTitle = document.getElementById('modalTitle');
                const modalContent = document.getElementById('modalContent');
                const modalFormula = document.getElementById('modalFormula');
                
                const error = Math.abs(actualKE - this.targetKE);
                const errorPercent = (error / this.targetKE) * 100;
                
                let title, content;
                if (errorPercent < 5) {
                    title = "Perfect Shot! üéØ";
                    content = "Excellent! You achieved the target kinetic energy with amazing precision.";
                } else if (errorPercent < 15) {
                    title = "Great Shot! üëç";
                    content = "Very close! Remember that kinetic energy grows with the square of velocity.";
                } else {
                    title = "Keep Trying! üí™";
                    content = errorPercent > 50 ? 
                        "Try adjusting both mass and velocity. Remember: doubling velocity quadruples the KE!" :
                        "Close attempt! Fine-tune your mass and velocity for better accuracy.";
                }
                
                if (modalTitle) modalTitle.textContent = title;
                if (modalContent) modalContent.textContent = content;
                if (modalFormula) modalFormula.textContent = 
                    `KE = ¬Ω √ó ${this.mass}kg √ó (${Math.round(this.velocity)}m/s)¬≤ = ${Math.round(actualKE)}J`;
                
                modal?.classList.remove('hidden');
            }
            
            /** @param {GameBall} ball @returns {boolean} */
            checkTargetHit(ball) {
                for (let target of this.targets) {
                    const distance = Math.sqrt((ball.body.position.x - target.x) ** 2 + (ball.body.position.y - target.y) ** 2);
                    if (distance < ball.radius + target.size / 2) {
                        const velocity = Math.sqrt(ball.body.velocity.x ** 2 + ball.body.velocity.y ** 2);
                        const currentKE = 0.5 * ball.mass * velocity * velocity;
                        const error = Math.abs(currentKE - this.targetKE);
                        const errorPercent = (error / this.targetKE) * 100;
                        
                        let stars = 1;
                        if (errorPercent < 5) stars = 3;
                        else if (errorPercent < 15) stars = 2;
                        
                        this.sound.playHit(stars > 1);
                        if (stars > 1) {
                            setTimeout(() => this.sound.playLevelComplete(), 300);
                        }
                        
                        this.showLevelComplete(stars, errorPercent);
                        return true;
                    }
                }
                return false;
            }
            
            /** @param {number} stars @param {number} errorPercent */
            showLevelComplete(stars, errorPercent) {
                const modal = document.getElementById('levelComplete');
                const starsElement = document.getElementById('stars');
                const performance = document.getElementById('performance');
                
                if (starsElement) starsElement.textContent = '‚≠ê'.repeat(stars) + '‚òÜ'.repeat(3 - stars);
                if (performance) performance.textContent = `Accuracy: ${Math.max(0, 100 - errorPercent).toFixed(1)}%`;
                
                modal?.classList.remove('hidden');
            }
            
            /** @param {number} deltaTime */
            updatePhysics(deltaTime) {
                // Update Matter.js engine
                Matter.Engine.update(this.engine, 16.67); // ~60fps
                
                // Update ball positions and check for hits
                for (let i = this.balls.length - 1; i >= 0; i--) {
                    const ball = this.balls[i];
                    
                    // Add trail
                    this.trails.push({
                        x: ball.body.position.x,
                        y: ball.body.position.y,
                        size: ball.radius * 0.6,
                        alpha: 0.8,
                        life: 1.0
                    });
                    
                    // Check target collision
                    if (this.checkTargetHit(ball)) {
                        Matter.World.remove(this.world, ball.body);
                        this.balls.splice(i, 1);
                        this.ballBodies.splice(this.ballBodies.indexOf(ball.body), 1);
                        continue;
                    }
                    
                    // Remove balls that are too slow or out of bounds
                    const velocity = Math.sqrt(ball.body.velocity.x ** 2 + ball.body.velocity.y ** 2);
                    if (velocity < 0.5 || ball.body.position.y > this.canvasHeight + 200) {
                        Matter.World.remove(this.world, ball.body);
                        this.balls.splice(i, 1);
                        this.ballBodies.splice(this.ballBodies.indexOf(ball.body), 1);
                    }
                }
                
                // Update trails
                for (let i = this.trails.length - 1; i >= 0; i--) {
                    const trail = this.trails[i];
                    trail.life -= deltaTime * 2;
                    trail.alpha = trail.life;
                    if (trail.life <= 0) {
                        this.trails.splice(i, 1);
                    }
                }
            }
            
            render() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                this.ctx.strokeStyle = document.documentElement.classList.contains('dark') ? 
                    'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
                this.ctx.lineWidth = 1;
                for (let x = 0; x < this.canvas.width; x += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                for (let y = 0; y < this.canvas.height; y += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
                
                // Draw cannon
                this.ctx.fillStyle = '#5D5CDE';
                this.ctx.beginPath();
                this.ctx.arc(this.cannonPos.x, this.cannonPos.y, 25, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw trajectory prediction
                if (this.isDragging && this.velocity > 0) {
                    const dx = this.dragStart.x - this.dragCurrent.x;
                    const dy = this.dragStart.y - this.dragCurrent.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        const vx = (dx / distance) * this.velocity;
                        const vy = (dy / distance) * this.velocity;
                        
                        this.ctx.fillStyle = 'rgba(93, 92, 222, 0.6)';
                        for (let t = 0; t < 3; t += 0.2) {
                            const x = this.cannonPos.x + vx * t * this.scale;
                            const y = this.cannonPos.y + (vy * t + 0.5 * 0.8 * t * t) * this.scale;
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }
                
                // Draw trails
                for (let trail of this.trails) {
                    this.ctx.fillStyle = `rgba(93, 92, 222, ${trail.alpha * 0.5})`;
                    this.ctx.beginPath();
                    this.ctx.arc(trail.x, trail.y, trail.size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Draw balls
                for (let ball of this.balls) {
                    this.ctx.fillStyle = '#FF6B6B';
                    this.ctx.beginPath();
                    this.ctx.arc(ball.body.position.x, ball.body.position.y, ball.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Ball highlight
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.arc(
                        ball.body.position.x - ball.radius * 0.3, 
                        ball.body.position.y - ball.radius * 0.3, 
                        ball.radius * 0.4, 
                        0, 
                        Math.PI * 2
                    );
                    this.ctx.fill();
                }
                
                // Draw targets
                for (let target of this.targets) {
                    this.ctx.strokeStyle = '#00D4AA';
                    this.ctx.fillStyle = 'rgba(0, 212, 170, 0.2)';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(target.x, target.y, target.size / 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.stroke();
                    
                    // Target center
                    this.ctx.fillStyle = '#00D4AA';
                    this.ctx.beginPath();
                    this.ctx.arc(target.x, target.y, 5, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Draw obstacles
                this.ctx.fillStyle = document.documentElement.classList.contains('dark') ? '#374151' : '#6B7280';
                for (let obstacle of this.obstacles) {
                    this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                }
            }
            
            /** @param {number} currentTime */
            gameLoop(currentTime = 0) {
                const deltaTime = Math.min((currentTime - this.lastTime) / 1000, 0.016); // Cap at 60fps
                this.lastTime = currentTime;
                
                if (this.gameRunning) {
                    this.updatePhysics(deltaTime);
                }
                
                this.render();
                requestAnimationFrame((time) => this.gameLoop(time));
            }
        }
        
        // Start the game when page loads
        window.addEventListener('load', () => {
            try {
                new BounceLabGame();
            } catch (error) {
                console.error('Failed to initialize game:', error);
            }
        });
    </script>
</body>
</html>
